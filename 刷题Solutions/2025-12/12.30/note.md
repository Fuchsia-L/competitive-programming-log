# ACM 练习笔记 (2025-12-30)

## [001] [431C - k-Tree](https://codeforces.com/problemset/problem/431/C) (动态规划 / 记忆化搜索)

* **题目大意**: 
在一棵每个节点都有 $k$ 条边（权值为 $1, 2, \dots, k$）的无限树中，寻找从根节点出发、路径总权重正好为 $n$、且路径中至少包含一条权重 $\ge d$ 的边的路径总数。结果对 $10^9 + 7$ 取模。

* **核心逻辑**: 
    1. **状态定义**: 使用 `memo[sum][check]` 记录当前路径总和为 `sum`，且当前是否已满足“包含 $\ge d$ 的边”（`check` 为 0 或 1）时的方案数。
    2. **转移方程**: 
       对于当前状态 `(sum, check)`，遍历下一条边的权值 $i \in [1, k]$：
       - 若 $i \ge d$，新状态为 `(sum + i, 1)`；
       - 若 $i < d$，新状态为 `(sum + i, check)`。
       $dp(sum, check) = \sum_{i=1}^{k} dp(sum + i, next\_check)$
    3. **递归边界**: 
       - 若 `sum > n`，返回 0（非法路径）；
       - 若 `sum == n`，返回 `check`（若满足条件则计数为 1，否则为 0）。

* **总结/关键点**: 
    - **复杂度分析**: 状态总数为 $n \times 2$，每个状态转移代价为 $O(k)$，总时间复杂度为 $O(n \cdot k)$。对于 $n, k \le 100$ 的数据量，运行效率极高。
    - **取模陷阱**: 在累加 `ans` 的过程中必须时刻取模，防止 `long long` 溢出（尽管本题 $k$ 较小，但这是好习惯）。
    - **初始化**: 记忆化数组 `memo` 需初始化为 -1，以区分“尚未计算”和“方案数为 0”。